<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toy: toy_interpreter.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../toylogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Toy<span id="projectnumber">&#160;1.1.6</span>
   </div>
   <div id="projectbrief">The Toy programming language is an imperative bytecode-intermediate embedded scripting language</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_f2c8af9107d7604b778bd4ea9fe0debe.html">interpreter</a></li><li class="navelem"><a class="el" href="../../dir_b3faaf715d3b6134f9a1fcdf9ae3d9ef.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">toy_interpreter.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>@???@  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="../../d7/d1d/toy__common_8h_source.html">toy_common.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d3/d5f/toy__literal_8h_source.html">toy_literal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/dfc/toy__literal__array_8h_source.html">toy_literal_array.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dd/da4/toy__literal__dictionary_8h_source.html">toy_literal_dictionary.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d2/db4/toy__scope_8h_source.html">toy_scope.h</a>&quot;</code><br />
</div>
<p><a href="../../dc/dcc/toy__interpreter_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae0b4ea5e1c9ef5a658456a15f5cf52bb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#ae0b4ea5e1c9ef5a658456a15f5cf52bb">Toy_Interpreter</a></td></tr>
<tr class="memdesc:ae0b4ea5e1c9ef5a658456a15f5cf52bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">@???@  <br /></td></tr>
<tr class="separator:ae0b4ea5e1c9ef5a658456a15f5cf52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af2533ca2ff39ed6095dc7e3e6b5effdb"><td class="memItemLeft" align="right" valign="top">TOY_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#af2533ca2ff39ed6095dc7e3e6b5effdb">Toy_injectNativeFn</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, const char *name, <a class="el" href="../../d3/d5f/toy__literal_8h.html#a75c718108573cac8d200bf51870c522b">Toy_NativeFn</a> func)</td></tr>
<tr class="memdesc:af2533ca2ff39ed6095dc7e3e6b5effdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will inject the given native function func into the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>'s current scope, with the name passed as name. Both the name and function will be converted into literals internally before being stored. It will return true on success, otherwise it will return false. The primary use of this function is within hooks.  <br /></td></tr>
<tr class="separator:af2533ca2ff39ed6095dc7e3e6b5effdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad12d0d2f6d24a75f8bb1c491751a013"><td class="memItemLeft" align="right" valign="top">TOY_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#aad12d0d2f6d24a75f8bb1c491751a013">Toy_injectNativeHook</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, const char *name, <a class="el" href="../../d3/d5f/toy__literal_8h.html#a6569b94d4c6ef28b9c1f948fdd14fc4a">Toy_HookFn</a> hook)</td></tr>
<tr class="memdesc:aad12d0d2f6d24a75f8bb1c491751a013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will inject the given native function hook into the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>'s hook cache, with the name passed in as name. Both the name and the function will be converted into literals internally before being stored. It will return true on success, otherwise it will return false.  <br /></td></tr>
<tr class="separator:aad12d0d2f6d24a75f8bb1c491751a013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bfaf21d66121d0ab5449ab293d9271"><td class="memItemLeft" align="right" valign="top">TOY_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#af7bfaf21d66121d0ab5449ab293d9271">Toy_callLiteralFn</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> func, <a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *arguments, <a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *returns)</td></tr>
<tr class="memdesc:af7bfaf21d66121d0ab5449ab293d9271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> which contains a function, with the arguments to that function passed in as arguments and the results stored in returns. It returns true on success, otherwise it returns false. The literal func can be either a native function or a Toy function, but it won't execute a hook.  <br /></td></tr>
<tr class="separator:af7bfaf21d66121d0ab5449ab293d9271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba99d0f920cb5bf608389765ed642d00"><td class="memItemLeft" align="right" valign="top">TOY_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#aba99d0f920cb5bf608389765ed642d00">Toy_callFn</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, const char *name, <a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *arguments, <a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *returns)</td></tr>
<tr class="memdesc:aba99d0f920cb5bf608389765ed642d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that will find a Toy_literal within the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>'s scope with a name that matches name, and will invoke it using Toy_callLiteralFn (passing in arguments and returns as expected).  <br /></td></tr>
<tr class="separator:aba99d0f920cb5bf608389765ed642d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace0eea619550a37252620c15d242c65"><td class="memItemLeft" align="right" valign="top">TOY_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#aace0eea619550a37252620c15d242c65">Toy_parseIdentifierToValue</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> *literalPtr)</td></tr>
<tr class="memdesc:aace0eea619550a37252620c15d242c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes, native functions will receive <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> identifiers instead of the values - the values can be retreived from the given interpreter's scope using the following pattern: <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> foobarIdn = foobar; if (<a class="el" href="../../d3/d5f/toy__literal_8h.html#a1d715b3f1a82754ee0bd2c037b995274">TOY_IS_IDENTIFIER(foobar)</a> &amp;&amp; Toy_parseIdentifierToValue(interpreter, &amp;foobar)) { freeLiteral(foobarIdn); //remember to free the identifier }.  <br /></td></tr>
<tr class="separator:aace0eea619550a37252620c15d242c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17c959e281f12cf9726538bc0cdd9a1"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#ae17c959e281f12cf9726538bc0cdd9a1">Toy_setInterpreterPrint</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, <a class="el" href="../../d3/d5f/toy__literal_8h.html#a176336391a32bc4eb6e8d776d3e19c35">Toy_PrintFn</a> printOutput)</td></tr>
<tr class="memdesc:ae17c959e281f12cf9726538bc0cdd9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the function called by the print keyword. By default, the following wrapper is used: static void printWrapper(const char* output) { printf("%s\n", output); }.  <br /></td></tr>
<tr class="separator:ae17c959e281f12cf9726538bc0cdd9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cfb38a79db92d0ee6938e82a99273d"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#a67cfb38a79db92d0ee6938e82a99273d">Toy_setInterpreterAssert</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, <a class="el" href="../../d3/d5f/toy__literal_8h.html#a176336391a32bc4eb6e8d776d3e19c35">Toy_PrintFn</a> assertOutput)</td></tr>
<tr class="memdesc:a67cfb38a79db92d0ee6938e82a99273d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function called by the assert keyword on failure. By default, the following wrapper is used: static void assertWrapper(const char* output) { fprintf(stderr, "Assertion failure: %s\n", output); }.  <br /></td></tr>
<tr class="separator:a67cfb38a79db92d0ee6938e82a99273d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7992b14204638895b6a8c121d7bd5b"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#afb7992b14204638895b6a8c121d7bd5b">Toy_setInterpreterError</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, <a class="el" href="../../d3/d5f/toy__literal_8h.html#a176336391a32bc4eb6e8d776d3e19c35">Toy_PrintFn</a> errorOutput)</td></tr>
<tr class="memdesc:afb7992b14204638895b6a8c121d7bd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function called when an error occurs within the interpreter. By default, the following wrapper is used: static void errorWrapper(const char* output) { fprintf(stderr, "%s", output); //no newline }.  <br /></td></tr>
<tr class="separator:afb7992b14204638895b6a8c121d7bd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1097c83258bcf4db018ee2cd4b7df4"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#a0e1097c83258bcf4db018ee2cd4b7df4">Toy_initInterpreter</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter)</td></tr>
<tr class="memdesc:a0e1097c83258bcf4db018ee2cd4b7df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>. It allocates memory for internal systems such as the stack, and zeroes-out systems that have yet to be invoked. Internally, it also invokes Toy_resetInterpreter to initialize the environment.  <br /></td></tr>
<tr class="separator:a0e1097c83258bcf4db018ee2cd4b7df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6866721f7636a5c5c9cd06565d8b65cd"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#a6866721f7636a5c5c9cd06565d8b65cd">Toy_runInterpreter</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter, const unsigned char *bytecode, size_t length)</td></tr>
<tr class="memdesc:a6866721f7636a5c5c9cd06565d8b65cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> and bytecode (as well as the length of the bytecode), checks its version information, parses and un-flattens the literal cache, and executes the compiled program stored in the bytecode. This function also consumes the bytecode, so the bytecode argument is no longer valid after calls. If the given bytecode's embedded version is not compatible with the current interpreter, then this function will refuse to execute. Re-using a <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> instance without first resetting it is possible (that's how the repl works), however doing so may have unintended consequences if the scripts are not intended to be used in such a way. Any variables declared will persist.  <br /></td></tr>
<tr class="separator:a6866721f7636a5c5c9cd06565d8b65cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd58b578f89fce99c1462fe0e78870e0"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#afd58b578f89fce99c1462fe0e78870e0">Toy_resetInterpreter</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter)</td></tr>
<tr class="memdesc:afd58b578f89fce99c1462fe0e78870e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees any environment that the scripts have built up, and generates a new one. It also injects several globally available functions:  <br /></td></tr>
<tr class="separator:afd58b578f89fce99c1462fe0e78870e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7aa4a348b6b0ac3775014653bd816a"><td class="memItemLeft" align="right" valign="top">TOY_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcc/toy__interpreter_8h.html#add7aa4a348b6b0ac3775014653bd816a">Toy_freeInterpreter</a> (<a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *interpreter)</td></tr>
<tr class="memdesc:add7aa4a348b6b0ac3775014653bd816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>, clearing all of the memory used within. That interpreter is no longer valid for use, and must be re-initialized.  <br /></td></tr>
<tr class="separator:add7aa4a348b6b0ac3775014653bd816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@???@ </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae0b4ea5e1c9ef5a658456a15f5cf52bb" name="ae0b4ea5e1c9ef5a658456a15f5cf52bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b4ea5e1c9ef5a658456a15f5cf52bb">&#9670;&#160;</a></span>Toy_Interpreter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>@???@ </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aba99d0f920cb5bf608389765ed642d00" name="aba99d0f920cb5bf608389765ed642d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba99d0f920cb5bf608389765ed642d00">&#9670;&#160;</a></span>Toy_callFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Toy_callFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *&#160;</td>
          <td class="paramname"><em>returns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that will find a Toy_literal within the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>'s scope with a name that matches name, and will invoke it using Toy_callLiteralFn (passing in arguments and returns as expected). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">arguments</td><td></td></tr>
    <tr><td class="paramname">returns</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af7bfaf21d66121d0ab5449ab293d9271" name="af7bfaf21d66121d0ab5449ab293d9271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bfaf21d66121d0ab5449ab293d9271">&#9670;&#160;</a></span>Toy_callLiteralFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Toy_callLiteralFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d6a/structToy__LiteralArray.html">Toy_LiteralArray</a> *&#160;</td>
          <td class="paramname"><em>returns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> which contains a function, with the arguments to that function passed in as arguments and the results stored in returns. It returns true on success, otherwise it returns false. The literal func can be either a native function or a Toy function, but it won't execute a hook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">arguments</td><td></td></tr>
    <tr><td class="paramname">returns</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="add7aa4a348b6b0ac3775014653bd816a" name="add7aa4a348b6b0ac3775014653bd816a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7aa4a348b6b0ac3775014653bd816a">&#9670;&#160;</a></span>Toy_freeInterpreter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_freeInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>, clearing all of the memory used within. That interpreter is no longer valid for use, and must be re-initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1097c83258bcf4db018ee2cd4b7df4" name="a0e1097c83258bcf4db018ee2cd4b7df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1097c83258bcf4db018ee2cd4b7df4">&#9670;&#160;</a></span>Toy_initInterpreter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_initInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>. It allocates memory for internal systems such as the stack, and zeroes-out systems that have yet to be invoked. Internally, it also invokes Toy_resetInterpreter to initialize the environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2533ca2ff39ed6095dc7e3e6b5effdb" name="af2533ca2ff39ed6095dc7e3e6b5effdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2533ca2ff39ed6095dc7e3e6b5effdb">&#9670;&#160;</a></span>Toy_injectNativeFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Toy_injectNativeFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d5f/toy__literal_8h.html#a75c718108573cac8d200bf51870c522b">Toy_NativeFn</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will inject the given native function func into the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>'s current scope, with the name passed as name. Both the name and function will be converted into literals internally before being stored. It will return true on success, otherwise it will return false. The primary use of this function is within hooks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">func</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aad12d0d2f6d24a75f8bb1c491751a013" name="aad12d0d2f6d24a75f8bb1c491751a013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad12d0d2f6d24a75f8bb1c491751a013">&#9670;&#160;</a></span>Toy_injectNativeHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Toy_injectNativeHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d5f/toy__literal_8h.html#a6569b94d4c6ef28b9c1f948fdd14fc4a">Toy_HookFn</a>&#160;</td>
          <td class="paramname"><em>hook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will inject the given native function hook into the <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a>'s hook cache, with the name passed in as name. Both the name and the function will be converted into literals internally before being stored. It will return true on success, otherwise it will return false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">hook</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aace0eea619550a37252620c15d242c65" name="aace0eea619550a37252620c15d242c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace0eea619550a37252620c15d242c65">&#9670;&#160;</a></span>Toy_parseIdentifierToValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Toy_parseIdentifierToValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> *&#160;</td>
          <td class="paramname"><em>literalPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sometimes, native functions will receive <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> identifiers instead of the values - the values can be retreived from the given interpreter's scope using the following pattern: <a class="el" href="../../d3/da0/structToy__Literal.html">Toy_Literal</a> foobarIdn = foobar; if (<a class="el" href="../../d3/d5f/toy__literal_8h.html#a1d715b3f1a82754ee0bd2c037b995274">TOY_IS_IDENTIFIER(foobar)</a> &amp;&amp; Toy_parseIdentifierToValue(interpreter, &amp;foobar)) { freeLiteral(foobarIdn); //remember to free the identifier }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">literalPtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afd58b578f89fce99c1462fe0e78870e0" name="afd58b578f89fce99c1462fe0e78870e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd58b578f89fce99c1462fe0e78870e0">&#9670;&#160;</a></span>Toy_resetInterpreter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_resetInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees any environment that the scripts have built up, and generates a new one. It also injects several globally available functions: </p>
<ul>
<li>set</li>
<li>get</li>
<li>push</li>
<li>pop</li>
<li>length</li>
<li>clear</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6866721f7636a5c5c9cd06565d8b65cd" name="a6866721f7636a5c5c9cd06565d8b65cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6866721f7636a5c5c9cd06565d8b65cd">&#9670;&#160;</a></span>Toy_runInterpreter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_runInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>bytecode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> and bytecode (as well as the length of the bytecode), checks its version information, parses and un-flattens the literal cache, and executes the compiled program stored in the bytecode. This function also consumes the bytecode, so the bytecode argument is no longer valid after calls. If the given bytecode's embedded version is not compatible with the current interpreter, then this function will refuse to execute. Re-using a <a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> instance without first resetting it is possible (that's how the repl works), however doing so may have unintended consequences if the scripts are not intended to be used in such a way. Any variables declared will persist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">bytecode</td><td></td></tr>
    <tr><td class="paramname">length</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67cfb38a79db92d0ee6938e82a99273d" name="a67cfb38a79db92d0ee6938e82a99273d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cfb38a79db92d0ee6938e82a99273d">&#9670;&#160;</a></span>Toy_setInterpreterAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_setInterpreterAssert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d5f/toy__literal_8h.html#a176336391a32bc4eb6e8d776d3e19c35">Toy_PrintFn</a>&#160;</td>
          <td class="paramname"><em>assertOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the function called by the assert keyword on failure. By default, the following wrapper is used: static void assertWrapper(const char* output) { fprintf(stderr, "Assertion failure: %s\n", output); }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">assertOutput</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb7992b14204638895b6a8c121d7bd5b" name="afb7992b14204638895b6a8c121d7bd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7992b14204638895b6a8c121d7bd5b">&#9670;&#160;</a></span>Toy_setInterpreterError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_setInterpreterError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d5f/toy__literal_8h.html#a176336391a32bc4eb6e8d776d3e19c35">Toy_PrintFn</a>&#160;</td>
          <td class="paramname"><em>errorOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the function called when an error occurs within the interpreter. By default, the following wrapper is used: static void errorWrapper(const char* output) { fprintf(stderr, "%s", output); //no newline }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">errorOutput</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae17c959e281f12cf9726538bc0cdd9a1" name="ae17c959e281f12cf9726538bc0cdd9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17c959e281f12cf9726538bc0cdd9a1">&#9670;&#160;</a></span>Toy_setInterpreterPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Toy_setInterpreterPrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da4/structToy__Interpreter.html">Toy_Interpreter</a> *&#160;</td>
          <td class="paramname"><em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d5f/toy__literal_8h.html#a176336391a32bc4eb6e8d776d3e19c35">Toy_PrintFn</a>&#160;</td>
          <td class="paramname"><em>printOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the function called by the print keyword. By default, the following wrapper is used: static void printWrapper(const char* output) { printf("%s\n", output); }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpreter</td><td></td></tr>
    <tr><td class="paramname">printOutput</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
